![CA Logo](http://www.collectiveaccess.org/sites/all/themes/collectiveaccess/img/body_logo.png)

# Collective Access: A Walkthrough

## Document Outline[Collective Access](http://www.collectiveaccess.org) is an extensible collection management system that has been designed to capture metadata about arbitrary objects, their relationships and aggregation, and their administration.This document has been prepared to initiate software developers and systems administrators who may be unfamiliar with Collective Access, the collection management domain, or both.The [Background](#background) section offers a dissection of the Chicago Film Archive’s website – which presents data and functionality provided by Collective Access – as a means of exposing the utility of Collective Access via an exploration of a canonical use case; moreover, this section is helpful for intellectually connecting user-facing data abstractions to their back-end implementation.The [Installation](#installation) and [Data Import](#data_import) sections acts as a walkthrough for installing a Collective Access instance (either on a local machine or a remote server) and populating it with data such that the usage and administration of the system is made clear.

Lastly, the [Modification](#modification) section provides examples of adding fields and bundles; redefining or renaming fields; and deleting unnecessary fields.## <a name="background"></a>BackgroundAt its core, Collective Access is an open source, platform-agnostic content management system that focuses on providing collection management functions to support the activities of organisations that act as guardians for artefacts having some long-term (usually cultural or intellectual) value.Where a content management system might be almost-solely concerned with storing and rendering multimedia, a collection management system typically augments this with additional metadata that captures the provenance, conservation, rights management, and other information pertaining to the long-term preservation of an object.Collective Access differs from most commercially-available collection management systems in that it provides an interface through which organisations are able to tailor the suite of fields, functions, and interfaces provided by the system. Although the source code for Collective Access may be forked and modified, the system has been designed in such a way as to encourage modifications to be made via the web-based administrator interface.### Example – The Chicago Film ArchiveThe extensibility of Collective Access makes it somewhat-difficult to inscribe the core functionality of the system; likewise, it is also difficult to determine its absolute limitations. In theory, given enough time, money, and effort, the system is capable of doing anything; certainly, there are several examples of use cases that have been shoe-horned in to the Collective Access framework, it is perhaps more productive to identify canonical usage of the system, and common abuses, and try to mimic the former without  succumbing to the latter.

Although the ‘developer documentation’ might seem sensible, it will be much more instructive to survey the variety of Collective Access variants that have already been elegantly deployed by [other institutions](http://www.collectiveaccess.org/projects).A canonical example of Collective Access being used in production is that of the Chicago Film Archive (CFA). Embedded within the CFA website is a collections browser whose functionality is predominantly provided by [Pawtucket](https://github.com/collectiveaccess/pawtucket) – the Collective Access presentation module that is responsible for providing access to data that is stored in the cataloguing module [Providence](https://github.com/collectiveaccess/providence).In [browsing the CFA’s collections](http://www.chicagofilmarchives.org/collections/index.php/Browse/clearCriteria), some of the fundamental functions and limitations of Collective Access are revealed.#### Basic TablesFirstly, note the existence of several so-called object types<sup>[1](#footnote_types)</sup>. The most important of these (note that there are [several others](http://docs.collectiveaccess.org/wiki/Basic_Tables)) include: `entities` (referred to here as People and Organisations); `places`; `collections` (i.e. objects that are related by way of a shared provenance, or a common intellectual theme); and `objects` (in this scenario, objects are specialised to suit the domain, and have been referred to as Videos, Films, Audio, and Manuscripts and Ephemera).Given that these types inform the structure of the database (they form the so-called [Basic Tables](http://docs.collectiveaccess.org/wiki/Basic_Tables)) that underlies Collective Access, as well as the associated models and controllers responsible for performing create, read, update, and delete operations, it is reasonable to consider that any data that cannot be captured by these types will probably require significant intervention.##### Fields, Relationships, and RepresentationsNow consider the records for a [specific video](http://www.chicagofilmarchives.org/collections/index.php/Detail/Object/Show/object_id/9219), and a [specific film](http://www.chicagofilmarchives.org/collections/index.php/Detail/Object/Show/object_id/14329); there are at least three observations to be made:Firstly, note that the set of fields used to describe the two kinds of objects are different (though they overlap). In particular, the Format field is irrelevant to a video (i.e. for the CFA, video is video – there are no video subtypes), though it is relevant for film (i.e. from the perspective of the CFA, 16mm film is consequentially distinct from 35mm film). This distinction hints at the extensibility of Collective Access: in this case, fields have added or removed to suit a specific object type (even though videos and films are both a `ca_object`.Secondly, notice the hyperlinked fields at the top and bottom of the record (e.g. the Part Of links, and the links under Form, Subjects, Related Places, and Genre). It should be obvious that the relationships between records are essentially encoded as relationships between Basic Tables – that is, the video and the film are each a `ca_object` (i.e. in the parlance of the database layer) that are connected to records in each of the `ca_lists` (Form, Subjects, Genre), `ca_collections` (Part Of), and `ca_places` (Related Places) Basic Tables.Lastly, observe that both records embed a digitised video of the original object. Collective Access refers to associated media files as _representations_.#### SummaryThis section introduced the high-level functionality of Collective Access with reference to low-level concepts. In particular, the notion of Basic Tables is an extremely important reference point for determining how data is stored internally; moreover, the predefined Basic Tables strongly hint at the extent of the set of entity types that the system is designed to manage.Additionally, the object, entity, collection, and representation types are relevant to the dataset that will be used in the remainder of this walkthrough – the CFA website portrays the canonical usage for these types.## <a name="installation"></a> Installation

This section outlines the requirements for establishing a Collective Access instance, and lists the steps necessary – with commentary – to install Collective Access and populate it with data. Instructions are provided for installing on a local machine or a remote server – note, though, that the remote install script is not considered to be ‘hardened’.### Local Install##### Requirements•	Providence•	Ansible deployment script•	Adam Art Gallery dataset•	Adam Art Gallery data mapping•	Adam Art Gallery images##### Installation1.	Do this2.	Do that3.	Do something else### Remote Install##### Requirements•	Providence?•	Ansible deployment script•	Adam Art Gallery dataset•	Adam Art Gallery data mapping•	Adam Art Gallery images##### Installation4.	Do this5.	Do that6.	Do something else

## <a name="data_import"></a> Data Import

### DatasetFor the purpose of demonstration, this walkthrough uses a subset of the Adam Art Gallery’s cataloguing data. The data was sourced from Vernon CMS – the extant collection management system used by the Gallery and other units within the University – and represents a subset of the data in the sense that the number of fields has been restricted to the twenty most-relevant fields (note, though, that all of the ca. 500 records – each representing an artwork – are represented).It is important to note that this restricted dataset omits ca. 250 other fields that are relevant to the Gallery’s collection management functions. In particular, location tracking; valuation history; and conservation management information are not present.### Data Mapping DocumentThe process for mapping existing data in to a Collective Access instance is informed by way of a data mapping document, which is captured in an [Excel spreadsheet](http://docs.collectiveaccess.org/wiki/File:Data_Import_Mapping_template.xlsx) that adheres to a predefined structure and vocabulary.Although there is useful documentation available that details the [mapping process](http://docs.collectiveaccess.org/wiki/Data_Import:_Creating_and_Running_a_Mapping) and [functions](http://docs.collectiveaccess.org/wiki/Data_Importer), though it is extremely general; instead, it may be useful to consider the specific example of the Gallery data as a gentle introduction (note that the data mapping document supplied for this walkthrough does not leverage all of the mapping functionality supported by Collective Access – in particular, groups, replacement values, and several refineries were irrelevant to the Gallery data).##### Skipped FieldsFirst, realise that fields 7, 8, 11, 12, 13, 14, 17, and 18 have been SKIPped. These fields correspond<sup>[2](#footnote_indexing)</sup> to columns 7, 8, 11, etc. of the file containing the data, and they will not be migrated in this first iteration due to the lack of a corresponding field in the unmodified Visual Resources Collection profile.##### Direct MappingNext, observe that – as indicated in the Source column – fields 1, 3, 4, 5, 15, and 16 (equivalently columns A, C, D, E, O, and P in the spreadsheet containing the data) have Mapping as their ‘rule type’, an entry in the ‘CA table.element’ column, and no other specifications. This indicates that the data in these columns will be mapped directly to the field with the corresponding bundle identifier in the ‘CA table.element’ column.##### Determining Bundle IdentifiersThere are numerous ways to determine the bundle identifier that targets the field that a source data element should be mapped to in Collective Access. The simplest method is to first consider the Basic Table that is most-relevant – if you are using the data to describe an object, this will be ca_object; a person will be ca_entity; etc<sup>[3](#footnote_basic_tables)</sup>. This will form the lefthand side of the dot-separated bundle identifier.The righthand side (i.e. the field name) can be determined via the Collective Access UI:1.	Log in to Collective Access2.	Access the User Interfaces editor by selecting Manage->Administration->User Interfaces3.	Click the edit button (the paper icon) in the row that corresponds to the editor whose Type is relevant4.	Select the Screen that displays the relevant field by clicking the associated edit icon5.	Under Screen content->Elements to display on this screen” hover over the relevant field name and note the Bundle name; this will form the righthand side of the Bundle Identifier.##### RefineriesFields 2, 6, 9, and 10 are mapped using a refinery. Anecdotally, a useful rule-of-thumb for determining whether a refinery is relevant is to consider whether the data element to be mapped should be embedded (in which case, direct mapping is more appropriate) or referential (i.e. as in, referenced using a foreign key, in the relational sense).As an example, Field 2 uses an entitySplitter refinery to create a reference to a person (i.e. entity) record. The parameters to the refinery (expressed as JSON) indicate that the relationshipType (i.e. the role, activity, property right, etc. that connects an entity to an object) is ‘artist’ (i.e. the referenced entity was the artist that created the work); the entityType is ‘individual’ (i.e. as opposed to an organisation); and the delimiter is a space (indicating that the name of the entity is space-delimited such that all characters leading up to the first space forms a forename, then a middle name, then a surname, etc.).Note that the relationshipType and entityType are types that must already be defined. In general, the easiest way to discover these is to browse through the relevant lists in the Collective Access UI.Figure 1: The Lists and vocabularies heriarchyTypes are found in the Lists & vocabularies hierarchy, which can be accessed via Manage->Lists & vocabularies. The valid entityTypes are easily discovered under the Entity types (entity_types) heading – the value in brackets (i.e. individual) indicates the identifier for that type that should be passed to the refinery.The relevant relationshipType can also be determined via the Collective Access UI by accessing the Relationship Types hierarchy under Manage->Administration->Relationship Types. Given that, in this scenario, it is necessary to relate an object to an entity, the most relevant type is object<->entity relationships. Here, the ‘had as artist’ (to be read as ‘this artwork had as its artist’) relationship type is identified internally as artist.The same steps were taken to determine the refinery parameters for the other refinery mappings used in creating the data mapping.##### Regular ExpressionsField 6 uses a regular expression to ‘trim’ extra information from the dimensions field. Dimensions are expressed in the data set in millimetres, then imperial units (which are themselves a conversion carried out internally in Vernon CMS anyway) – the regular expression will remove everything from ‘mm’ onwards leaving only the length x width expression.Given that the result of the regular expression is not returned during the data import phase, it is important to test that the specified regular expression performs as expected; it is helpful to use a PHP regular expression tester to validate the expression.##### Settings Documentation surrounding the data mapping settings is not particularly helpful with regard to the table and type settings – a data mapping will probably work, even if all but these two settings are set incorrectly.The documentation for the table setting indicates that this setting “Sets the table for the imported data Sets the table for the imported data”. In practice, it seems that a heuristic for setting this should be “what does my dataset principally describe?” – if the dataset predominantly contains information about objects, then the table setting should be set to ca_objects; if it predominantly contains information about people (e.g. biographical data pertaining to artists), then ca_entities would be more appropriate.The type setting is defined as the “Type to set all imported records to...”. In the Art Gallery example, type is set to painting – this was derived from the Lists & vocabularies hierarchy (similarly to the relationshipType in the Refineries subsection).Note that the dataset actually contains object types other than paintings, though their type is not explicitly identified (nor automatically inferrable) and as such the type specified in the settings cannot be overridden (i.e. by mapping to ca_objects.type_id) on a per-record basis.

## <a name="modification"></a>Modification

## <a name="footnotes"></a>Footnotes
1. <a name="footnote_types"></a>The full list of types is enumerated [here](http://docs.collectiveaccess.org/wiki/Basic_Tables)
2. <a name="footnote_indexing"></a>Note that 1-indexing is used such that Column A corresponds to 1, B to 2, etc.
3. <a name="footnote_basic_tables"></a>Recall that the [Basic Tables documentation](http://docs.collectiveaccess.org/wiki/Basic_Tables) maps concepts to Basic Table names